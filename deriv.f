      SUBROUTINE DERIV (GEO,GRAD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INCLUDE 'SIZES'
      DIMENSION GEO(3,*), GRAD(*)
      COMMON /GEOVAR/ NVAR,LOC(2,MAXPAR),DUMMY(MAXPAR)
      COMMON /MOLKST/ NUMAT,NAT(NUMATM), NFIRST(NUMATM), NMIDLE(NUMATM),
     + NLAST(NUMATM), NORBS, NELECS, NALPHA, NBETA, NCLOSE, NOPEN
      COMMON /GRAVEC/ COSINE
      COMMON /GEOSYM/ NDEP, IDUMYS(600)
      COMMON /WMATRX/ W(N2ELEC)
      COMMON /PATH  / LATOM,LPARAM,REACT(100)
      COMMON /XYZGRA/ DXYZ(3,NUMATM)
      COMMON /HMATRX/ H(MPACK)
      COMMON /NUMCAL/ NUMCAL
      COMMON /ATHEAT/ ATHEAT
C***********************************************************************
C
C    DERIV CALCULATES THE DERIVATIVES OF THE ENERGY WITH RESPECT TO THE
C          INTERNAL COORDINATES. THIS IS DONE BY FINITE DIFFERENCES.
C
C    THE MAIN ARRAYS IN DERIV ARE:
C        LOC    INTEGER ARRAY, LOC(1,I) CONTAINS THE ADDRESS OF THE ATOM
C               INTERNAL COORDINATE LOC(2,I) IS TO BE USED IN THE DERIVATIVE
C               CALCULATION.
C        GEO    ARRAY \GEO\ HOLDS THE INTERNAL COORDINATES.
C        GRAD   ON EXIT, CONTAINS THE DERIVATIVES
C
C***********************************************************************
      COMMON /KEYWRD / KEYWRD
      CHARACTER*80 KEYWRD
      DIMENSION CHANGE(3), COORD(3,NUMATM), COLD(3,NUMATM)
     +,         XDERIV(3), XPARAM(300), ERRFN(MAXPAR)
      LOGICAL DEBUG, TIMES, HALFE, FAST, SCF1, CI
      DATA ICALCN /0/, ERRFN /MAXPAR*0.D0/
      IF(ICALCN.NE.NUMCAL) THEN
          DEBUG = (INDEX(KEYWRD,'DERIV') .NE. 0)
          GRLIM=0.01D0
          IF(INDEX(KEYWRD,'FULSCF') .GT.0) GRLIM=1.D9
          TIMES = (INDEX(KEYWRD,'TIME') .NE. 0)
          CI    = (INDEX(KEYWRD,'C.I.') .NE. 0)
          SCF1  = (INDEX(KEYWRD,'1SCF') .NE. 0)
          HALFE = (NOPEN.GT.NCLOSE)
          ICALCN=NUMCAL
          IDELTA=-7
          FAST=.TRUE.
          IF(   CI   ) FAST=.FALSE.
          IF(HALFE) IDELTA=-4
          CHANGE(1)= 10.D0**IDELTA
          CHANGE(2)= 10.D0**IDELTA
          CHANGE(3)= 10.D0**IDELTA
C
C    CHANGE(I) IS THE STEP SIZE USED IN CALCULATING THE DERIVATIVES.
C    FOR "CARTESIAN" DERIVATIVES, CALCULATED USING DCART, AN INFINITESIMAL
C    STEP, HERE 0.000001, IS ACCEPTABLE. IN THE HALF-ELECTRON METHOD A
C    QUITE LARGE STEP IS NEEDED AS FULL SCF CALCULATIONS ARE NEEDED, AND
C    THE DIFFERENCE BETWEEN THE TOTAL ENERGIES IS USED. THE STEP CANNOT BE
C    VERY LARGE, AS THE SECOND DERIVITIVE IN FLEPO IS CALCULATED FROM THE
C    DIFFERENCES OF TWO FIRST DERIVATIVES.
C    CHANGE(1) IS FOR CHANGE IN BOND LENGTH, (2) FOR ANGLE, AND (3) FOR
C              DIHEDRAL.
C
          XDERIV(1)= 0.5D0/CHANGE(1)
          XDERIV(2)= 0.5D0/CHANGE(2)
          XDERIV(3)= 0.5D0/CHANGE(3)
      ENDIF
      GNORM=0.D0
      IF(NVAR.EQ.0) RETURN
      DO 6 I=1,NVAR
      XPARAM(I)=GEO(LOC(2,I),LOC(1,I))
   6  GNORM=GNORM+GRAD(I)**2
      GNORM=SQRT(GNORM)
C#      IF(FAST)
      FAST=(GNORM .GT. GRLIM .AND. .NOT. SCF1 .OR. .NOT. HALFE)
      TIME1=SECOND()
      IF(NDEP.NE.0) CALL SYMTRY
      CALL GMETRY(GEO,COORD)
      IF( .NOT. FAST ) THEN
          IF(DEBUG)WRITE(6,'('' DOING FULL SCF''''S IN DERIV'')')
          CALL HCORE(COORD,H,W,ENUCLR)
          CALL ITER(H,W,AA,.TRUE.)
          AA=(AA+ENUCLR)
       ENDIF
          CALL DCART(COORD,DXYZ)
          IF(NDEP.NE.0) CALL SYMTRY
          CALL GMETRY(GEO,COLD)
      SUM11=1.D-9
      SUM22=1.D-9
      SUM12=1.D-9
      DO 19 I=1,NVAR
          K=LOC(1,I)
          L=LOC(2,I)
          XSTORE=XPARAM(I)
          DO 17 J=1,NVAR
   17       GEO(LOC(2,J),LOC(1,J))=XPARAM(J)
         GEO(L,K)=XSTORE-CHANGE(L)
          IF(NDEP.NE.0) CALL SYMTRY
          CALL GMETRY(GEO,COORD)
C
C    USE LOOKUP TABLE OF CARTESIAN DERIVITIVES TO WORK OUT INTERNAL
C    COORDINATE DERIVITIVE.
C
          TOTL=0.D0
          DO 13 II=1,NUMAT
              DO 13 KK=1,3
                  TOTL=TOTL+DXYZ(KK,II)*(COORD(KK,II)-COLD(KK,II))
  13              CONTINUE
          TOTL=TOTL*XDERIV(L)*0.5D0
C
C   IF NEEDED, CALCULATE "EXACT" DERIVITIVES.
C
          IF( .NOT. FAST ) THEN
              CALL HCORE(COORD,H,W,ENUCLR)
              CALL ITER(H,W,EE,.TRUE.)
              EE=(EE+ENUCLR)
              TOTL1=(AA-EE)*23.061D0*XDERIV(L)
          ERRFN(I)=TOTL1-TOTL
          ENDIF
          GEO(L,K)=XSTORE
          SUM11=SUM11+GRAD(I)**2
          SUM22=SUM22+TOTL**2
          SUM12=SUM12+TOTL*GRAD(I)
          GRAD(I)=TOTL+ERRFN(I)
  19  CONTINUE
      IF(DEBUG) THEN
      WRITE(6,'('' GRADIENTS'')')
      WRITE(6,'(10F8.3)')(GRAD(I),I=1,NVAR)
      WRITE(6,'('' ERROR FUNCTION'')')
      WRITE(6,'(10F8.3)')(ERRFN(I),I=1,NVAR)
      ENDIF
      COSINE=SUM12/SQRT(SUM11*SUM22)
      IF(DEBUG)
     +WRITE(6,'('' COSINE OF SEARCH DIRECTION ='',F13.6)')COSINE
      IF( .NOT. FAST ) COSINE=1.D0
      IF(TIMES)
     +WRITE(6,'('' TIME FOR DERIVATIVES'',F12.6)')SECOND()-TIME1
      RETURN
      END
